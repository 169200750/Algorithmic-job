# Algorithmic-job
算法设计与分析的一个简单期末作业

## 问题描述
在一个 3×3的网格中，1∼8这 8个数字和一个 x 恰好不重不漏地分布在这3×3的网格中。在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。我们的目的是通过让 x 先后与右、下、右三个方向的数字交换成功得到如下排列（称为正确排列）。  
![image](https://github.com/169200750/Algorithmic-job/assets/85624974/ebcf1d73-ad56-42a0-b155-f313bb021019)

现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换，若不能到达最终状态则输出-1。  
### 输入格式
将 3×3的初始网格通过一维数组或字符串形式进行输入如：1 2 3 x 4 6 7 5 8  
### 输出格式
包含一个整数，表示最少交换次数。如果不存在解决方案，则输出 −1。  

## 数学模型的建立
根据题意，本题最后只需要输出到达目标状态最少的操作次数即可，若不能到达目标状态则输出-1；  

### 状态表示
对于每操作一次，都会得到一个不同状态的3x3矩阵，我们可以将整个矩阵看作是一个点，从而表示每一个操作的状态，其次，可以使用字符串string来存储当前的状态。主要表现如下图：  
![image](https://github.com/169200750/Algorithmic-job/assets/85624974/0247f781-1101-4789-83b8-5caee4ff047e)  
其中矩阵转换成字符串的转换方式如下：  
![image](https://github.com/169200750/Algorithmic-job/assets/85624974/c99adaab-a2e3-46b0-8a04-05c0eb4b215b)  

### 状态距离的记录
每转换一次操作步骤+1,判断当前的状态是否为最终的目标状态，在所有能完成目标状态的距离下，通过BFS查找到的操作步骤一定是最短的。故解向量为：X{X1,X2,X3……,Xn-1,Xn}；  
![image](https://github.com/169200750/Algorithmic-job/assets/85624974/a8de9f96-e5b2-4c48-b51c-d75faac56a96)  

## 总体设计
### BFS+剪枝
这里的查找思想主要是通过宽度优先搜索（BFS）进行查找最短路，将输入的初始状态存储好之后，进行判断，可以进行移动的操作，总共是四个方向（上下左右），我们可以定义两个数组来完成上下左右移动的操作选择，如（-1，0）就是上一行的当前列；（0，-1）就是当前行的前一列；（1，0）的话就是下一行的当前列；（0，1）便是当前行的右边一列，通过循环则可以完成当前状态的移动转换，则数组设计如下：  
dx[] = {-1,0,1,0}; dy[] = {0,-1,0,1}。  
在找到当前状态后，可根据一个for循环直接找到满足边界条件的四种状态，每次检查是否有对用的最终目标结果，并判断当前这个状态是否是第一次出现的状态，若是第一次出现，则记录其距离，在这之后需要还原当前的状态，为下一次的移动操作做准备。  
那么根据分析，我们可以把每一次移动的结果，整体表示成一个点，而这个点便是一种移动的状态，从而得出解空间树：  
![image](https://github.com/169200750/Algorithmic-job/assets/85624974/22f82de3-152f-4dc9-8516-6f0b7b6917dc)  
每一次把一种状态转为一个字符串，并将其存入队列，记录好每一次的状态，使用一个哈希表来保存各个序列与对应的交换次数；每一次从队头中取出队列，计算出这个序列通过交换能得到的序列。如果能到得的序列是个新序列（哈希表中没有这个序列），就把这个新序列放入队尾，哈希表中记录新序列对应的交换次数。如果在这些过程中得到了最后的结果队列，则输出交换次数即可，否则输出-1。例如：  
![image](https://github.com/169200750/Algorithmic-job/assets/85624974/12531a59-84fb-4718-988c-e191bef77593)  
经过观察，上午例子只需交换三次即可找到最正确的答案。  

## 存储结构选择
对于每一中状态这里采用队列进行存储，队列中的类型为：string类型，主要为：queue<sting>；而对于每一种状态所需要的操作步骤，采用哈希表进行存贮，这里采用C++中具有映射型unordered_map<string,int>进行存储。
存储结构分析  
这里每一种状态采用队列主要是方便出队入队时对状态的判断，以及对应的状态更新，我把每一个矩阵的状态都看作一个字符串存进哈希表中，以便后期的更新删除操作。  
其中距离（也就是操作次数）通过哈希表中key值来表示唯一的一种状态，其对应value值就是相应的操作次数。

### 时间复杂度
假设初始状态到目标状态的最短路径长度为n，每个状态最多可以扩展出4个相邻状态，则在BFS算法中，需要搜索的状态总数为：  
1 + 4 + 4^2 + ... + 4^n  
根据等比数列求和公式，可以得到上式的结果为：(4^(n+1) - 1) / 3  
因此，BFS算法的时间复杂度为O(4^n)，其中n为初始状态到目标状态的最短路径长度。由于此问题的状态空间非常大，n一般都比较大，因此BFS算法的时间复杂度非常高。  

### 空间复杂度
在BFS算法中，需要使用一个队列来存储待扩展的状态，队列的最大长度即为算法的空间复杂度。假设队列中的状态总数为N，则空间复杂度为O(N)。  
根据上面的分析可知，在八数码问题中，最坏情况下，需要存储的状态总数为：  
1 + 4 + 4^2 + ... + 4^n  
因此，BFS算法的空间复杂度为O(4^n)，与时间复杂度相同。由于状态空间非常大，队列的长度可能会非常大，因此空间复杂度也非常高。  


